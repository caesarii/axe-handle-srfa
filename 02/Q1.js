
// 1. 实现插入排序
const log = console.log;

// 循环不变式是指 A[0, j-1], 该数组中包含元素组中 0 到 j-1 的元素, 而且是已排序的
// 初始化: 初始状态 j = 1, A[0] 自然是已排序的
// 保持: 在一次迭代中, 将A[j]插入到A[0, j-1]的恰当位置, 形成A[0, j], 也是排序的
// 终止: 在循环终止时, j = A.length, A[0, A.length - 1] 是已排序的 A

const insertSort = (A) => {
    // 插入排序的设计思路是增量方法, 就是从一个元素开始排序(自然是排序的), 每次增加一个元素然后排序

    // A[0...j-1]是排序好的数组, 初始状态 j =1, A[0...0]已排序
    // A[0...j-1]是所谓的循环不变式

    // 外循环的目的是遍历未排序元素并插入, 即A[j...], 所以从 j=1 开始遍历数组
    for(let j = 1; j < A.length; j++){

        // key 是当前要排序的元素, 也就是增量
        const key = A[j]

        // 内循环的目的是将增量元素插入已排序的 A[0...j-1], 所以逆序遍历 A[0...j-1], 此时 A[1...j-1] 表示为 A[0, i]
        // 如果A[i] > key, 则将其后移, 否则key应插入到A[i+1]
        // 为什么这里的后移不会覆盖其他元素: 初次后移时覆盖的是A[j], 已暂存到 key, 其他的后移覆盖的是已经后移的元素, 所以其实不会覆盖
        let i;
        for(i = j - 1; i > -1; i--) {
            if (A[i] > key) {
                A[i + 1] = A[i]
            } else {
                break;
            }
        }
        A[i + 1] = key;
    }
}


if(require.main === module) {
    const list = [38, 545, 6, 9, 324, 1, 4, 564,17, 754]
    insertSort(list)
    log(list)
}